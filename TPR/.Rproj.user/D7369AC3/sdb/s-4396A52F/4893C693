{
    "collab_server" : "",
    "contents" : "---\ntitle: 'Emo APIs Analysis'\nauthor: 'Mohamed'\ndate: '2017'\noutput: html_document\n---\n---\noutput:\n  html_document: default\n  pdf_document: default\n---\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(knitr)\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(gridExtra)\n\n## Gives count, mean, standard deviation, standard error of the mean, and confidence interval (default 95%).\n##   data: a data frame.\n##   measurevar: the name of a column that contains the variable to be summariezed\n##   groupvars: a vector containing names of columns that contain grouping variables\n##   na.rm: a boolean that indicates whether to ignore NA's\n##   conf.interval: the percent range of the confidence interval (default is 95%)\nsummarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,\n                      conf.interval=.95, .drop=TRUE) {\n    library(plyr)\n\n    # New version of length which can handle NA's: if na.rm==T, don't count them\n    length2 <- function (x, na.rm=FALSE) {\n        if (na.rm) sum(!is.na(x))\n        else       length(x)\n    }\n\n    # This does the summary. For each group's data frame, return a vector with\n    # N, mean, and sd\n    datac <- ddply(data, groupvars, .drop=.drop,\n      .fun = function(xx, col) {\n        c(N    = length2(xx[[col]], na.rm=na.rm),\n          mean = mean   (xx[[col]], na.rm=na.rm),\n          sd   = sd     (xx[[col]], na.rm=na.rm)\n        )\n      },\n      measurevar\n    )\n\n    # Rename the 'mean' column    \n    datac <- rename(datac, c('mean' = measurevar))\n\n    datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean\n\n    # Confidence interval multiplier for standard error\n    # Calculate t-statistic for confidence interval: \n    # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1\n    ciMult <- qt(conf.interval/2 + .5, datac$N-1)\n    datac$ci <- datac$se * ciMult\n\n    return(datac)\n}\n\n## Norms the data within specified groups in a data frame; it normalizes each\n## subject (identified by idvar) so that they have the same mean, within each group\n## specified by betweenvars.\n##   data: a data frame.\n##   idvar: the name of a column that identifies each subject (or matched subjects)\n##   measurevar: the name of a column that contains the variable to be summariezed\n##   betweenvars: a vector containing names of columns that are between-subjects variables\n##   na.rm: a boolean that indicates whether to ignore NA's\nnormDataWithin <- function(data=NULL, idvar, measurevar, betweenvars=NULL,\n                           na.rm=FALSE, .drop=TRUE) {\n    library(plyr)\n\n    # Measure var on left, idvar + between vars on right of formula.\n    data.subjMean <- ddply(data, c(idvar, betweenvars), .drop=.drop,\n     .fun = function(xx, col, na.rm) {\n        c(subjMean = mean(xx[,col], na.rm=na.rm))\n      },\n      measurevar,\n      na.rm\n    )\n\n    # Put the subject means with original data\n    data <- merge(data, data.subjMean)\n\n    # Get the normalized data in a new column\n    measureNormedVar <- paste(measurevar, '_norm', sep='')\n    data[,measureNormedVar] <- data[,measurevar] - data[,'subjMean'] +\n                               mean(data[,measurevar], na.rm=na.rm)\n\n    # Remove this subject mean column\n    data$subjMean <- NULL\n\n    return(data)\n}\n\n## Summarizes data, handling within-subjects variables by removing inter-subject variability.\n## It will still work if there are no within-S variables.\n## Gives count, un-normed mean, normed mean (with same between-group mean),\n##   standard deviation, standard error of the mean, and confidence interval.\n## If there are within-subject variables, calculate adjusted values using method from Morey (2008).\n##   data: a data frame.\n##   measurevar: the name of a column that contains the variable to be summariezed\n##   betweenvars: a vector containing names of columns that are between-subjects variables\n##   withinvars: a vector containing names of columns that are within-subjects variables\n##   idvar: the name of a column that identifies each subject (or matched subjects)\n##   na.rm: a boolean that indicates whether to ignore NA's\n##   conf.interval: the percent range of the confidence interval (default is 95%)\nsummarySEwithin <- function(data=NULL, measurevar, betweenvars=NULL, withinvars=NULL,\n                            idvar=NULL, na.rm=FALSE, conf.interval=.95, .drop=TRUE) {\n\n  # Ensure that the betweenvars and withinvars are factors\n  factorvars <- vapply(data[, c(betweenvars, withinvars), drop=FALSE],\n    FUN=is.factor, FUN.VALUE=logical(1))\n\n  if (!all(factorvars)) {\n    nonfactorvars <- names(factorvars)[!factorvars]\n    message('Automatically converting the following non-factors to factors: ',\n            paste(nonfactorvars, collapse = ', '))\n    data[nonfactorvars] <- lapply(data[nonfactorvars], factor)\n  }\n\n  # Get the means from the un-normed data\n  datac <- summarySE(data, measurevar, groupvars=c(betweenvars, withinvars),\n                     na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)\n\n  # Drop all the unused columns (these will be calculated with normed data)\n  datac$sd <- NULL\n  datac$se <- NULL\n  datac$ci <- NULL\n\n  # Norm each subject's data\n  ndata <- normDataWithin(data, idvar, measurevar, betweenvars, na.rm, .drop=.drop)\n\n  # This is the name of the new column\n  measurevar_n <- paste(measurevar, '_norm', sep='')\n\n  # Collapse the normed data - now we can treat between and within vars the same\n  ndatac <- summarySE(ndata, measurevar_n, groupvars=c(betweenvars, withinvars),\n                      na.rm=na.rm, conf.interval=conf.interval, .drop=.drop)\n\n  # Apply correction from Morey (2008) to the standard error and confidence interval\n  #  Get the product of the number of conditions of within-S variables\n  nWithinGroups    <- prod(vapply(ndatac[,withinvars, drop=FALSE], FUN=nlevels,\n                           FUN.VALUE=numeric(1)))\n  correctionFactor <- sqrt( nWithinGroups / (nWithinGroups-1) )\n\n  # Apply the correction factor\n  ndatac$sd <- ndatac$sd * correctionFactor\n  ndatac$se <- ndatac$se * correctionFactor\n  ndatac$ci <- ndatac$ci * correctionFactor\n\n  # Combine the un-normed means with the normed results\n  merge(datac, ndatac)\n}\n\n# Multiple plot function\n#\n# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n# - cols:   Number of columns in layout\n# - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n#\n# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n# then plot 1 will go in the upper left, 2 will go in the upper right, and\n# 3 will go all the way across the bottom.\n#\nmultiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {\n  library(grid)\n\n  # Make a list from the ... arguments and plotlist\n  plots <- c(list(...), plotlist)\n\n  numPlots = length(plots)\n\n  # If layout is NULL, then use 'cols' to determine layout\n  if (is.null(layout)) {\n    # Make the panel\n    # ncol: Number of columns of plots\n    # nrow: Number of rows needed, calculated from # of cols\n    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                    ncol = cols, nrow = ceiling(numPlots/cols))\n  }\n\n if (numPlots==1) {\n    print(plots[[1]])\n\n  } else {\n    # Set up the page\n    grid.newpage()\n    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n\n    # Make each plot, in the correct location\n    for (i in 1:numPlots) {\n      # Get the i,j matrix positions of the regions that contain this subplot\n      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n\n      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                      layout.pos.col = matchidx$col))\n    }\n  }\n}\n\n```\n\n```{r read data}\nemoapidata = read.table(file = './chi18-emoapi-faked-data.csv', header=TRUE, sep = ',')\n```\n\n```{r display data, echo=FALSE, results='asis'}\nkable(head(emoapidata))\n```\n\n## Sampling\nH1: ER accuracy will increase with the level of sampling using ER APIs (using api)\n\n```{r summarizing the data : calm emotion}\nemoapidataWithinCalm <- summarySEwithin(emoapidata, measurevar='calm', withinvars=c('emotionapi', 'imgfps'), idvar='imgfilename', na.rm=FALSE, conf.interval=.95)\n\nemoapidataWithinJoy <- summarySEwithin(emoapidata, measurevar='joy', withinvars=c('emotionapi', 'imgfps'), idvar='imgfilename', na.rm=FALSE, conf.interval=.95)\n\nemoapidataWithinSurprise <- summarySEwithin(emoapidata, measurevar='surprise', withinvars=c('emotionapi', 'imgfps'), idvar='imgfilename', na.rm=FALSE, conf.interval=.95)\n\nemoapidataWithinOthers <- summarySEwithin(emoapidata, measurevar='others', withinvars=c('emotionapi', 'imgfps'), idvar='imgfilename', na.rm=FALSE, conf.interval=.95)\n```\n\n```{r drawing CI : calm emotion}\npd <- position_dodge(0.1) # move them .05 to the left and right\n\n# calm\np1 <- ggplot(emoapidataWithinCalm, aes(x=imgfps, y=calm, colour=emotionapi, group=emotionapi)) + \n    geom_errorbar(aes(ymin=calm-ci, ymax=calm+ci), colour='black', width=.1, position=pd) +\n    geom_line(position=pd) +\n    geom_point(position=pd, size=3, shape=21, fill='white') + # 21 is filled circle\n    xlab('Frame per second (fps)') +\n    ylab('Emotion\\'s value') +\n    scale_colour_hue(name='ER APIs',    # Legend label, use darker colors\n                     breaks=c('aws-rekognition', 'google-vision', 'ms-emotion'),\n                     labels=c('AWS Rokognition', 'Google Vision', 'Microsoft Emotion'),\n                     l=40) +                    # Use darker colors, lightness=40\n    ggtitle('Calm') +\n    expand_limits(y=0) +                        # Expand y range\n    theme_bw() +\n    theme(legend.justification=c(1,0), legend.position=c(1,0), , plot.title = element_text(hjust = 0.5))  \n\n# surprise\np2 <- ggplot(emoapidataWithinSurprise, aes(x=imgfps, y=surprise, colour=emotionapi, group=emotionapi)) + \n    geom_errorbar(aes(ymin=surprise-ci, ymax=surprise+ci), colour='black', width=.1, position=pd) +\n    geom_line(position=pd) +\n    geom_point(position=pd, size=3, shape=21, fill='white') + # 21 is filled circle\n    xlab('Frame per second (fps)') +\n    ylab('Emotion\\'s value') +\n    scale_colour_hue(name='ER APIs',    # Legend label, use darker colors\n                     breaks=c('aws-rekognition', 'google-vision', 'ms-emotion'),\n                     labels=c('AWS Rokognition', 'Google Vision', 'Microsoft Emotion'),\n                     l=40) +                    # Use darker colors, lightness=40\n    ggtitle('Surprise') +\n    expand_limits(y=0) +                        # Expand y range\n    theme_bw() +\n    theme(legend.justification=c(1,0), legend.position=c(1,0), , plot.title = element_text(hjust = 0.5))  \n\n# joy\np3 <- ggplot(emoapidataWithinJoy, aes(x=imgfps, y=joy, colour=emotionapi, group=emotionapi)) + \n    geom_errorbar(aes(ymin=joy-ci, ymax=joy+ci), colour='black', width=.1, position=pd) +\n    geom_line(position=pd) +\n    geom_point(position=pd, size=3, shape=21, fill='white') + # 21 is filled circle\n    xlab('Frame per second (fps)') +\n    ylab('Emotion\\'s value') +\n    scale_colour_hue(name='ER APIs',    # Legend label, use darker colors\n                     breaks=c('aws-rekognition', 'google-vision', 'ms-emotion'),\n                     labels=c('AWS Rokognition', 'Google Vision', 'Microsoft Emotion'),\n                     l=40) +                    # Use darker colors, lightness=40\n    ggtitle('Joy') +\n    expand_limits(y=0) +                        # Expand y range\n    theme_bw() +\n    theme(legend.justification=c(1,0), legend.position=c(1,0), , plot.title = element_text(hjust = 0.5))\n\n# others\np4 <- ggplot(emoapidataWithinOthers, aes(x=imgfps, y=others, colour=emotionapi, group=emotionapi)) + \n    geom_errorbar(aes(ymin=others-ci, ymax=others+ci), colour='black', width=.1, position=pd) +\n    geom_line(position=pd) +\n    geom_point(position=pd, size=3, shape=21, fill='white') + # 21 is filled circle\n    xlab('Frame per second (fps)') +\n    ylab('Emotion\\'s value') +\n    scale_colour_hue(name='ER APIs',    # Legend label, use darker colors\n                     breaks=c('aws-rekognition', 'google-vision', 'ms-emotion'),\n                     labels=c('AWS Rokognition', 'Google Vision', 'Microsoft Emotion'),\n                     l=20) +                    # Use darker colors, lightness=40\n    ggtitle('Others') +\n    expand_limits(y=0) +                        # Expand y range\n    theme_bw() +\n    theme(legend.justification=c(1,0), legend.position=c(1,0), , plot.title = element_text(hjust = 0.5)) \n\ngrid.arrange(p1, p2, ncol = 2)\n\ngrid.arrange(p3, p4, ncol = 2)\n\n```\n\n",
    "created" : 1499509255791.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "417060353",
    "id" : "4893C693",
    "lastKnownWriteTime" : 1499526373,
    "last_content_update" : 1499526374010,
    "path" : "~/Code/RJCIHM/TPR/emoapi.Rmd",
    "project_path" : "emoapi.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}